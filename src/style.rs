/*
    This module contains functions that are used to build a style tree.
    This module will take a DOM node and lookup up matching selectors against
    the provided stylesheet.
*/

use css::{Declaration, Selector, SimpleSelector, Specificity, Stylesheet, Value};
use dom::{ElementData, Node, NodeType};
use std::collections::HashMap;

type StyleMap = HashMap<String, Value>;

#[derive(PartialEq)]
pub enum Display {
    Inline,
    Block,
    None,
}

#[derive(Debug)]
pub struct StyledNode<'a> {
    // Needed to specify lifetime according to compiler; TODO: look up why that is necessary here
    node: &'a Node,
    styles: StyleMap,
    pub children: Vec<StyledNode<'a>>,
}

pub fn build_style_tree<'a>(root: &'a Node, stylesheet: &'a Stylesheet) -> StyledNode<'a> {
    StyledNode {
        node: root,
        styles: match root.node_type {
            NodeType::Text(_) => StyleMap::new(),
            NodeType::Element(ref element_data) => get_node_styles(element_data, stylesheet),
        },
        children: root.children
            .iter()
            .map(|node| build_style_tree(node, stylesheet))
            .collect(), // this should be generated by calling "build_style_tree" on each child node
    }
}

pub fn is_matching_selector(elem: &ElementData, selector: &Selector) -> bool {
    match selector {
        Selector::Simple(simple_selector) => is_matching_simple_selector(elem, simple_selector),
    }
}

pub fn is_matching_simple_selector(elem: &ElementData, selector: &SimpleSelector) -> bool {
    // TODO: find a better way to compare elem and selector Option/String values

    let is_tag_match = match selector.tag_name {
        Some(ref s) => s == elem.tag_name.as_str(),
        None => false,
    };

    let is_id_match = match selector.id {
        Some(ref id) if elem.get_id().is_some() => id == elem.get_id().unwrap().as_str(),
        Some(_) => false,
        None => false,
    };

    let is_class_match = elem.get_classlist()
        .iter()
        .any(|class| selector.class.contains(&class.to_string()));

    is_tag_match || is_id_match || is_class_match
}

pub fn get_element_rules<'a>(elem: &ElementData, stylesheet: &'a Stylesheet) -> Vec<(Specificity, &'a Vec<Declaration>)> {
    let mut rules = Vec::new();
    for rule in stylesheet.rules.iter() {
        for selector in rule.selectors.iter() {
            if is_matching_selector(elem, &selector) {
                rules.push((selector.specificity(), &rule.declarations));
            }   
        }
    }
    rules.sort_by(|a,b| a.0.cmp(&b.0));
    rules
}

pub fn get_node_styles(elem: &ElementData, stylesheet: &Stylesheet) -> StyleMap {
    /*
        1. iterate through stylesheet rules
        2. match elem attributes against each rule selector
        3. if match, loop through rule declarations and apply them to StyleMap

        note: rules in Stylesheet should already be sorted by increasing specificity
    */

    let mut styles = StyleMap::new();
    let rules = get_element_rules(elem, stylesheet);

    for rule in rules {
        for declaration in rule.1 {
            styles.insert(declaration.property.clone(), declaration.value.clone());
        }
    }

    styles
}

impl<'a> StyledNode<'a> {
    pub fn value(&self, name: &str) -> Option<Value> {
        self.styles.get(name).cloned()
    }

    /// Return the specified value of property `name`, or property
    /// `fallback_name` if that doesn't exist, or value `default` if
    /// neither does.
    pub fn lookup(&self, name: &str, fallback_name: &str, default: &Value) -> Value {
        self.value(name).unwrap_or_else(|| self.value(fallback_name)
                        .unwrap_or_else(|| default.clone()))
    }

    pub fn display(&self) -> Display {
        match self.value("display") {
            Some(Value::Keyword(s)) => match &*s {
                "block" => Display::Block,
                "none" => Display::None,
                _ => Display::Inline
            },
            _ => Display::Inline
        }
    }
}
