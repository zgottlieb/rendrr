/*
    This module contains functions that are used to build a style tree.
    This module will take a DOM node and lookup up matching selectors against
    the provided stylesheet.
*/

use css::{Selector, SimpleSelector, Stylesheet, Value};
use dom::{ElementData, Node, NodeType};
use std::collections::HashMap;

type StyleMap = HashMap<String, Value>;

#[derive(Debug)]
pub struct StyledNode<'a> {
    // Needed to specify lifetime according to compiler; TODO: look up why that is necessary here
    node: &'a Node,
    styles: StyleMap,
    children: Vec<StyledNode<'a>>,
}

pub fn build_style_tree<'a>(root: &'a Node, stylesheet: &'a Stylesheet) -> StyledNode<'a> {
    StyledNode {
        node: root,
        styles: match root.node_type {
            NodeType::Text(_) => StyleMap::new(),
            NodeType::Element(ref element_data) => get_node_styles(element_data, stylesheet),
        },
        children: root.children
            .iter()
            .map(|node| build_style_tree(node, stylesheet))
            .collect(), // this should be generated by calling "build_style_tree" on each child node
    }
}

pub fn is_matching_selector(elem: &ElementData, selector: &Selector) -> bool {
    match selector {
        Selector::Simple(simple_selector) => is_matching_simple_selector(elem, simple_selector),
    }
}

pub fn is_matching_simple_selector(elem: &ElementData, selector: &SimpleSelector) -> bool {
    // TODO: find a better way to compare elem and selector Option/String values

    // elem.tag_name.as_str() != selector.tag_name.clone().unwrap().as_str();
    let is_tag_match = match selector.tag_name {
        Some(ref s) => s == elem.tag_name.as_str(),
        None => false,
    };

    // let is_id_match = elem.get_id().unwrap().as_str() != selector.id.clone().unwrap().as_str();
    let is_id_match = match selector.id {
        Some(ref id) if elem.get_id().is_some() => id == elem.get_id().unwrap().as_str(),
        Some(_) => false,
        None => false,
    };

    let is_class_match = !elem.get_classlist()
        .iter()
        .any(|class| selector.class.contains(&class.to_string()));

    if is_tag_match || is_id_match || is_class_match {
        return false;
    } else {
        return true;
    }
}

pub fn get_node_styles(elem: &ElementData, stylesheet: &Stylesheet) -> StyleMap {
    /*
        1. iterate through stylesheet rules
        2. match elem attributes against each rule selector
        3. if match, loop through rule declarations and apply them to StyleMap

        note: rules in Stylesheet should already be sorted by increasing specificity
    */

    let mut styles = StyleMap::new();

    for rule in stylesheet.rules.iter() {
        for selector in rule.selectors.iter() {
            if is_matching_selector(elem, &selector) {
                for declaration in &rule.declarations {
                    styles.insert(declaration.property.clone(), declaration.value.clone());
                }
            }
        }
    }

    styles
}
